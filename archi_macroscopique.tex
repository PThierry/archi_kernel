%%
%%
%% archi_macroscopique.tex for  in /doctorat/ece/partenariat/cours/archi_kernel
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Mon Sep  6 16:18:47 2010 Philippe THIERRY
%% Last update Fri Oct  1 16:28:52 2010 Philippe THIERRY
%%

\chapter{Architecture macroscopique}

\section{La décomposition des sources}
\label{sec:decomp_sources}

\paragraph{}
Les sources du noyau Linux contiennent environ dix millions de ligne de code, majoritairement écrites
en C. A la différence d'un micro-noyau qui contient environ dix mille lignes de code, il est ici
nécessaire de prévoir une organisation des sources stricte et fine.

\paragraph{}
Dans le cadre du projet Linux, les sources sont décomposées par spécialités, et ce sur plusieurs
niveaux. Les sources Linux sont donc sous forme d'une arborescence de répertoires.

\paragraph{}
Afin de mieux comprendre les différents composants présent dans le noyau, le tableau \ref{tab:linux_dirs}
décrit, pour chaque répertoire, les composants qui y sont hébergés. Ce tableau ne décrit que le
premier niveau de répertoires, mais l'arbre source Linux est assez profond, pouvant descendre
jusqu'à quatre ou cinq niveaux de répertoires selon le type de composant. On le constate d'ailleurs
lors de l'utilisation de l'outil de configuration du noyau, qui présente une arborescence assez
similaire.

\paragraph{}
\begin{center}
\tablefirsthead{\hline%
     Répertoire & Contenu \\%
     \hline \hline}
   \tablehead{\hline \multicolumn{2}{|l|}{\small\sl suite de la page précédente}\\
   \hline  Répertoire & Contenu\\ \hline\hline}
   \tabletail{\hline \multicolumn{2}{|r|}{\small\sl Suite page
   suivante~\ldots}\\\hline} \tablelasttail{\hline}
   \bottomcaption{Répartition des fonctionalités dans l'arborescence noyau Linux}
   \par
\begin{supertabular}{l|l}
\label{tab:linux_dirs}
 {\bf arch} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Ensemble du code spécifique à une architecture matérielle donnée. Une dizaine
 d'architecture est aujourd'hui supportée par le noyau Linux
 \vspace{2mm}
 \end{minipage}
 \\
 {\bf block} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Implémentation des éléments génériques aux périphériques en mode block (disques dur, etc)
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf crypto} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Implémentation de l'ensemble des algorithme cryptographique ainsi que de la
 {\it glue} (On appelle {\it glue} l'ensemble des wrappers, API et macros surcouchant un c{\oe}ur
 fonctionnel) associée
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf drivers} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Ensemble des drivers de périphérique. Ces derniers sont répartis par famille (acpi, net,
 usb, video...)
 \vspace{2mm}
 \end{minipage}
 \\
 
 {\bf firmware} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Ensemble des firmwares et des éléments bas niveau nécessaires pour s'interconnecter
 avec certains périphériques.
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf fs} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Implémentation des différents filesystems. On y retrouve ext2, ext3, ext4, ntfs, vfat,
 procfs, sysfs ou encore la sucrcouche générique à tous : vfs
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf include} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Ensemble des fichiers d'en-tête du noyau exportés vers les applicatifs. Ce répertoire
 contient l'ensemble de l'API standard Linux.
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf init} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Dans ce répertoire, on retrouve l'ensemble des éléments nécessaire au boot et n'étant pas
 spécifique à une architecture. On retrouve ainsi la gestion de l'initramfs ou encore le montage
 du rootfs.
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf ipc} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Implémentation des IPC POSIX (Inter-Process Communications) : les pipes, les shared-memory
 et les signaux.
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf kernel} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Implémentation des éléments c{\oe}ur du noyau : gestion des modules, des  processus, de
 l'ordonnanceur, des ACL POSIX ou encore des timers.
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf lib} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Ce répertoire contient la bibliothèque de fonctions utilisée par l'ensemble du noyau. Il
 s'agit des fonction de base nécessaire à l'implémentation de tout module Linux.
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf mm} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Implémentation des allocateurs mémoire de la famille mmap. Contient également les fonctions
 générique de gestion de la MMU.
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf net} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 On retrouve dans ce répertoire l'ensemble des piles réseaux supportées par Linux, de la
 couche 2 à la couche 4 de la pile OSI. On y retrouve la pile IPv4, IPv6, ATM, etc.
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf security} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Ensemble des éléments de durcissement standard du noyau Linux (SELinux, Tomoyo, modules
 TPM, etc).
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf sound} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Implémentation de l'architecture de gestion du son (hors pilotes de périphériques)
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf tools} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Implémentation de divers outils de mesure.
 \vspace{2mm}
 \end{minipage}
 \\

{\bf scripts} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Le répertoire script contient les élements nécessaire à la compilation du noyau. Il s'agit
 majoritairement de fichiers de scripts génrant certains éléments comme le header de version du
 noyau. Ce répertoire ne possède pas de composant source (hors headers) intégrés au binaire du
 noyau.
 \vspace{2mm}
 \end{minipage}
 \\

 {\bf virt} &
 \begin{minipage}{0.7\linewidth}
 \vspace{2mm}
 Support de la virtualisation. On y retrouve le sous-système KVM (Kernel Virtual Machine) et
 les élements associés. UML (User Mode Linux), qui n'est pas de la virtualisation à proprement parlé, est géré dans
 {\it arch}.
 \vspace{2mm}
 \end{minipage}
 \\
\end{supertabular}
\end{center}

\section{Linux, un noyau modulaire}
\label{sec:linux_modular}

\subsection{Principe des modules}

\paragraph{}
Linux est un noyau modulaire. Cela signifie qu'une partie de son implémentation peut être chargée à
la volée, en fonction du besoin, tandis qu'une base plus petite est directement chargée en
mémoire.\\
Le principal intérêt et la portabilité. En effet, les premiers blocs de code qu'on a tendance à
rendre modulable sont les pilotes. En effet, pas deux machines possèdent exactement la même liste
de périphérique, cependant il est nécessaire de pouvoir installer Linux sur un maximum de machines
du parc existant. Pour cela, on intègre dans le noyau les éléments de base (support du processeur,
support de la mémoire, des interruptions et des filesystems). Afin de pouvoir s'intégrer dans
diverses machine, on ajoute au noyau un nombre maximum de pilotes de périphériques, sous forme de
modules. Ces pilotes tiennent de la place disque, ce qui n'est aujourd'hui pas une gène, mais ne
sont pas chargé en mémoire vive tant qu'ils ne sont pas nécessaires. Cela permet ainsi de pouvoir
répondre à un nombre maximum de besoins sans pour autant créer autant de noyaux que de machines.

\paragraph{}
Cette problématique est moins présente dans le cadre des architectures Windows. En effet, les
différents pilotes de périphériques sont fournis par des tiers, après l'installation du noyau.
C'est aujourd'hui moins vrai, Microsoft intégrant cependant un certain nombre de pilotes génériques
afin de fournir une interface utilisable avant l'installation des pilotes tiers.

\subsection{Les modules et le boot : l'initramfs}

\paragraph{}
Sous Linux, on peut quasiment tout mettre sous forme de module. Ainsi, il est possible de
construire un noyau de base à très petite empreinte mémoire, mais qui seul est insufisant pour
pouvoir initier la séquence de boot.

\paragraph{}
C'est par exemple le cas si l'ensemble des implémentations de systèmes de fichiers sont sous forme
de modules. Lorsque le noyau démarre, il est alors incapable de charger la partition racine, le
{\it rootfs}, afin d'aller y chercher les modules nécessaires.\\
Pour compenser ce problème, un système de fichier virtuel a été créé, le ramfs, dans lequel sont
placé les modules nécessaires au démarrage de la machine. Il est créé sous forme d'un fichier
disjoint du fichier noyau. C'est le bootloader qui s'occupe de fournir au noyau un accès à ce
fichier, sans que ce dernier n'ai besoin de supporter un système de fichier supplémentaire. Le
noyau charge alors les différents modules nécessaires au chargement de la machine, en allant lire
directement dans le fichier initramfs.\\
Initramfs est le successeur de l'initrd, dont le but est le même, mais ayant moins de capacité. En
effet, l'initramfs fournit plus que des modules supplémentaires. Il fournit également un rootfs
minimum, avec un shell simple, en cas de problème au début de la phase de démarrage du système.

\subsection{Le système de gestion des modules et des dépendances}

\paragraph{}
Une fois le système démarré et le véritable rootfs chargé, le noyau possède un accès aux
répertoires de base du systèmes que sont {\tt /bin}, {\tt /etc} et {\tt /lib}. Ces trois
répertoires contiennent les éléments nécessaire à la poursuite du démarrage. On y retrouve ainsi :
\begin{itemize}
\item {\bf init}, afin de lancer le premier processus du système, qui à son tour se chargera de
démarrer les autres processus
\item {\bf mount}, afin de monter les possibles autres partitions du système
\item les fichiers de configuration contenus dans {\bf etc}, comme la table des systèmes de fichiers
({\tt fstab}, la liste des comptes utilisateurs systèmes fichier {\tt passwd} et d'autres éléments
nécessaire à l'initiatisation du système.
\item {\bf les modules}, présents dans le répertoire {\tt /lib}, sous forme d'une arboresence de
fichier {\tt .ko}, associés à des méta-données de dépendances.
\end{itemize}

\paragraph{}
Le noyau, en cas de besoin, est alors capable de charger à la volée les modules supplémentaire via
le système de gestion des modules. Le système de chargement dynamique de module se fait au travers
d'une table de correspondance. L'exemple suivant d'écrit le cas d'un périphérique matériel:

\paragraph{}
Lorsque le noyau récupère les informations sur les périphériques, ces dernières sont sous la forme
d'un couple fabriquant/identifiant. Ce système est normalisé, et l'ensemble des périphériques sont
capables de fournir cette indication au logiciel.\\
Lorsqu'on écrit un pilote de périphérique, on précise au travers de procédures standard du noyau
Linux la liste des périphérique que le pilote sait gérer. Cette liste contient un ensemble de
couple fabriquant/identifiant. Au moment de la compilation du noyau, lorsque le pilote est compilé
sous forme de module (et sous forme statique également), la liste des périphérique qu'il supporte
est ajouté à la table du noyau, avec le nom du pilote. Le noyau Linux est alors capable de
connaitre quel pilote il doit charger, et par extension quel module. Il s'appuie alors sur le
système de gestion des modules contenu dans le répertoire {\tt lib} pour trouver et charger le
module et l'ensemble de ses dépendances si ce dernier en as. Bien entendu, c'est lors de la
compilation que les dépendances sont ajoutées automatiquement et compilées, afin de s'assurer de
leur présence au moment de l'exécution.


\section{Les différents éléments constituants le noyau Linux}
\label{sec:linux_content}

\subsection{Le support de l'architecture}

\paragraph{}
L'élément principal du noyau est le support de l'architecture. Cet élément est nécessaire afin que
le noyau puisse démarrer. Mais quels sont les éléments nécessaires pour supporter l'architecture ?\\
Tout d'abord, il est nécessaire de supporter la base : le c{\oe}ur processeur. Il est donc
nécessaire de connaître ses registres et comment s'en servir. Il est également nécessaire de
connaître les opcodes nécessaire à la gestion des éléments de base comme la MMU, les DMA ou encore
le frequency scaling. Il est également nécessaire de configurer correctement le timer, si cela n'a
pas été fait par le bootloader.

\paragraph{}
On retrouve ainsi dans cette partie le vecteur d'interruption et l'ensemble des handlers associés,
ainsi que la gestion de ces derniers (enregistrement du vecteur d'interruption, activation et
configuration du PIC, etc). Sans cette configuration de base, le processeur fonctionne en vase clos
et le système est inutilisable (pas de timer, pas de clavier, pas de périphériques, etc).

\paragraph{}
De plus, il est nécessaire de configurer la MMU\footnote{Memory Management Unit}, afin de passer en
mode paginé. Cela permet de gérer les adresses virtuel et de permettre l'emploi de la fonction {\tt
mmap}. De plus, la MMU fournit un cloisonnement mémoire nécessaire au bon fonctionnement de la
machine, via la configuration de {\it contextes} MMU par le noyau.\\
Malheureusement, il n'y a pas de norme d'interface pour la MMU, et par conséquent il y a autant de
MMU que de processeur, d'où sa présence dans la partie support de l'architecture.

\paragraph{}
Enfin, les contrôleurs DMA maître, souvent présents directement dans le processeur, doivent être
configurés. Pour finir, le support du bus PCI et au travers de lui la découverte des périphériques
est géré également dans cette partie.

\subsection{La gestion mémoire}
\paragraph{}
La MMU est gérée dans le support de l'architecture. Cependant, d'un point de vue plus
macroscopique, il est nécessaire de gérer les pages et la mémoire vive. Il faut donc implémenter
une ou des politiques d'allocation mémoire (nommées dans Linux {\it slub}et {\it slab allocators}.
De plus, lors de la construction d'un processus et de la configuration de son contexte MMU, le
positionnement des sections et la configuration de l'espace d'adressage doit être fait. C'est dans
cette partie que sont gérés ces différents éléments.

\subsection{Le gestionnaire d'interruptions}
\paragraph{}
Il est décrit dans la partie support de l'architecture que la présence d'un vecteur d'interruption
est nécessaire, et que le noyau doit enregistrer se dernier auprès du processeur. Le vecteur
d'interruption est en général une liste d'adresses. Dans le cas des processeurs de la famille IA32,
ce vecteur possède une longueur de 256 adresses. On retrouve 16 cases pour les interruptions
matérielles, 128 cases pour les interruptions logicielles, et le reste en réserve. Cependant,
chaque adresse correspond à la position d'une fonction en mémoire, cette fonction étant spécialisée
pour l'interruption associée. Ces fonctions sont toutes implémentées dans le noyau Linux et
nécessite parfois l'appel à un pilote externe, comme par exemple le gestionnaire d'interruption
clavier, qui nécessite... un pilote clavier.\\
On retrouve également les handlers d'exception matérielles et logicielles, dont toute une partie de
l'implémentation n'est pas spécifique au matériel, mais relatif à la politique de Linux. Ainsi, là
où une exception de type page-miss implique une mise à jour de l'arborescence de page du processus
associé via requête à la MMU, une exception de type division par zéro implique la terminaison du
processus en cause.

\subsection{Les syscalls}
\paragraph{}
Dans les denières versions du noyau 2.6 (version 2.6.35), Linux possède une cinquantaine de
syscalls. Ces derniers sont directement appellable par les processus userspace. Leur appel est
directement remplacé par la chaîne de compilation par une requête d'interruption 80. Cette
interruption, gérée dans le vecteur d'interruption, redirige vers l'appel système associé en
fonction de la valeur de certains registres, mise à jour plus haut dans le code assembleur de la
tâche.

\paragraph{}
La plupart du temps, les syscall fournissent une inerface d'échange de données entre le processus
et le noyau, via un buffer. C'est le cas de l'appel système {\tt read}, dont le prototype est le
suivant :
\begin{lstlisting}
int	read(int fd, char *buf, int flags);
\end{lstlisting}

\paragraph{}
En général, les appels systèmes sont décomposés en plusieurs blocs. Le premier bloc est propre au
coeur du noyau Linux, et prend en charge les éléments génériques. Ainsi, dans le cadre du read, ce
dernier vérifie que fd existe bien dans la table des descripteurs de fichiers.

\paragraph{}
Un descripteur de fichier est un entier auquel est associé un fichier dans le système de fichiers.
Il est alors nécessaire de passer la main on second bloc, implémenté dans le pilote du système de
fichier virtuel {\tt vfs}. Ce dernier est une interface homogène pour l'ensemble des systèmes de
fichiers sous jacents, et il y en a beaucoup. Ainsi, si le fichier se trouve dans une partition
ext3, ce bloc passe la main à l'implémentation du read du pilote de l'ext3, si c'est dans le
procfs, il passe alors la main au pilote du procfs, si c'est dans le devfs ({\tt /dev}), alors le
troisième bloc appellé est le pilote du {\it devfs}.\\
Dans certain cas, ce troisième bloc est le dernier. C'est le cas par exemple des pilotes de
systèmes de fichiers physiques (systèmes de fichiers des partitions disques). Cependant, dans le
cas des systèmes de fichiers virtuel, un autre driver se cache encore en dessous.\\
C'est le cas par exemple pour {\it devfs}. Ce dernier passe alors la main à l'implémentation du
pilote de périphérique associé au fichier device.

\paragraph{}
On constate que l'implémentation des appels systèmes est stratifié. Cela permet de mieux maîtriser
les différentes étapes du traitement, mais implique une consommation en terme de cycles processeur.
Fort heureusement, l'exécution de l'appel système se fait dans l'espace d'adressage du processus
appelant. Cela évite ainsi un changement de contexte. Cependant, un changement de niveau de
privilège doit être effectué, l'appel système se faisant avec les droits du noyau.\\
Afin de rendre ces deux propriétés compatibles, une partie de la section de code du noyau est
prémappée dans l'espace d'adressage du noyau, ce qui permet d'appeller les différentes fonctions du
noyau via un simple branchement, après changement de niveaux de privilège.

\subsection{Les IPC}
\paragraph{}
Linux implémente les IPC POSIX. Il s'agit des trois suivantes :
\begin{itemize}
\item Les signaux, permettant de communiquer de manière simple au travers de l'implémentation de
handlers de signaux au niveau logiciel. Parmis ces signaux, trois (\FIXME à vérifier) ne sont pas
redéfinissable par une tache : SIGKILL et SIGTERM et SIGILL. Ces signaux provoque la terminaison
de la tache cible. Un signal n'est qu'une valeur numérique. Elle ne contient aucune autre
information que sa valeur.
\item Les pipes, fournissant un canal de communication unidirectionnel. Les pipes étant vus sous
formes de descripteurs de fichiers partagés entre deux taches, ces dernières doivent être créées
par une même tache parente, responsable de la création du pipe en avance de phase.
\item Les mémoire partagées. Il s'agit de la famille {\it shm}. Il s'agit de page mémoires (dont la
granularité est généralement de 4096 octets) que deux processus partagent. L'écriture ou la lecture
dans cette page mémoire se fait au travers des fonctions de la famille {\it shm} comme {\tt shmget}.
\end{itemize}

Il existe d'autre moyens de communiquer entre processus, comme par exemple au travers d'une socket
UNIX, mais il ne s'agit pas, dans ce cas, d'une IPC.

\subsection{L'ordonnanceur est la gestion des taches}

\paragraph{}
Un noyau doit impérativement gérer des taches, faute de quoi sont intérêt serait fortement réduit.
POSIX fournit un certain nombre de propriétés qu'une tache doit posséder :
\begin{itemize}
\item un identifiant, nommé {\it pid} (Process IDentifier)
\item une tache parente, connue via son identifiant, le {\it ppid} (Parent Process IDentifier)
\item un utilisateur propriétaire de la tache, définissant un userid associé, et en conséquence
      ses droit d'accès utilisateur.
\item un groupe propriétaire de la tache, définissant un groupid associé, et ses droit d'accès
      groupe.
\item une politique d'ordonnancement, pouvant être de type RR (Round Robin), FIFO, ou encore OTHER)
\item une priorité, afin de l'intégrer dans sa politique d'ordonnancement
\item un age, pouvant avoir un impact sur sa priorité, au travers de la gestion du vieillissement
      des taches.
\item sa priorité modifiée, nommée priorité {\it nice}, conséquence du vieillissement mais
      également d'une possible redéfinition de sa priorité via la commande {\tt nice}.
\item un contexte MMU, correspondant à un identifiant d'espace d'adressage, afin de savoir quel
      espace charger au moment de son ordonnancement.
\item un tableau de descripteur de fichier, listant l'ensemble des file descriptors et des fichiers
      associés ouvert, ainsi que les droits demandés à l'ouverture
\item Quelques propriétés en terme de charge maximum, comme le nombre de file descriptors maximum
      ouvrable.
\end{itemize}

\paragraph{}
Une tache possède d'autres propriétés, mais celles nommées ici sont les principales. On constate
donc qu'une tache est un élément complexe, nécessitant une grosse structure de donnée, ainsi qu'une
interface riche de gestion de tache.

\paragraph{}
Qui dit tache dit bien sur ordonnanceur. Linux possède de base plusieurs types d'ordonnanceurs. Il
possède tout d'abord des ordonnanceurs temps réel (FIFO et RR), mais également non-temps réel. A
ses ordonnanceur sont associées des priorités:
\begin{enumerate}
\item 100 priorités différentes pour les ordonnanceurs temps réel, de 0 (la plus basse) à 99
\item 40 priorités pour les ordonnanceurs non temps réel, de 20 (la plus basse), à -19.
\end{enumerate}
Cela fait au total 140 priorités à gérer. Le fait qu'il y aie plusieurs ordonnanceurs s'exécutant en
même temps, le système d'ordonnancement de Linux est assez complexe. Cependant, depuis le noyau
2.6.11, l'ordonnanceur standard pour le non temps réel ({\it SCED\_OTHER}) possède une complexité
en $O(1)$. Avec l'accroissement du nombre de taches s'exécutant en parallèle sur une machine,
s'était une nécessité.

\paragraph{}
De plus, afin d'éviter les locks liés aux architectures multi-c{\oe}urs, Linux est passé d'une file
unique de gestion des taches à une file par c{\oe}ur. Cela évite que deux instance de
l'ordonnanceur s'exécutant en parallèle génère un retard sur l'une d'entre elle.

\subsection{Les systèmes de fichiers}
\paragraph{}
La gestion des systèmes de fichiers sous Linux fonctionne en couche. Le but est que du point de vue
utilisateur, un seul système de fichier ne soit vu. Cela permet de fournir aux applications une
interface d'accès unique et homogène.\\
Le schéma \ref{fig:fs_archi} fournit un exemple d'architecture en couche telle que présente dans
Linux. Ce schéma n'est pas exhaustif : il existe d'autres systèmes de fichiers non présentés ici
comme le {\it NTFS} ou encore, parmi les systèmes de fichiers virtuels, les {\it sysfs}, {\it ramfs}
et {\it tmpfs}, mais le principe de fonctionnement reste le même pour tous, avec un accès au travers
du vfs.

\begin{center}
\begin{figure}[H]
\input{pictures/fs_archi.tex}
\caption{Architecture en couche de la gestion des systèmes de fichiers}
\label{fig:fs_archi}
\end{figure}
\end{center}

\subsection{La pile réseau}

\paragraph{}
La pile réseau Linux est très riche et ne se limite pas au seul couple Ethernet/IP. On y retrouve
également un certain nombre de protocoles legacy comme ATM, TDMA ou encore TokenRing, ainsi que le
support des normes IEEE 802.11, 802.15.4, etc. Du fait de sa richesse, la pile réseau Linux est
très complexe. Sont décrit ici les structures principales, dans le cadre de la pile IP.

\paragraph{}
Afin d'exploiter au mieux les capacités réseau de Linux, il existe un composant, assez volumineux
(environ cent mille lignes de code) nommé {\it Netfilter}. Ce composant est ce qu'on appelle un
treillis: il accompagne le traitement du flux réseau dans le noyau, et propose des accroche
permettant d'effectuer des traitements spécifique à divers moment du cheminement des paquets dans
la pile réseau.

\paragraph{}
Pour comprendre l'architecture de Netfilter il est avant tout nécessaire de bien avoir en tête la pile
IP, et sa décomposition entre le noyau et le mode utilisateur. Pour rappel, le traitement des
en-têtes s'effectue dans le noyau jusqu'à la couche 4 du modèle OSI. C'est ensuite à l'applicatif
de traiter le reste du paquet.
La liaison entre noyau et userspace se fait, dans le cadre d'un environnement POSIX comme Linux,
via des sockets. Netfilter n'intervient que dans la partie noyau, mais peut parfois remonter plus
haut que la couche 4, c'est ce qu'on appelle le conntracking. Son usage est décrit plus loin.

\paragraph{}
Avant que le paquet n'arrive au niveau de la couche liaison de la pile IP, il a déjà parcouru du
chemin dans le noyau Linux. En effet, ce dernier a été chargé à partir de la mémoire de la carte réseau,
et structuré de manière standardisée dans une structure propre au noyau Linux appelée {\it
sk\_buff}.\\
Cette structure contient un certain nombre d'informations sur le paquet, comme par exemple :
\begin{itemize}
\item Sa taille
\item Son interface d'entrée (pointeur vers la stucture {\it net\_device} correspondante du noyau)
\item Son interface de sortie (champ remplit au moment du routage du paquet si sa destination n'est
      pas locale)
\item Sa date d'arrivée
\item Des pointeurs divers vers les en-têtes liaison et IP, ainsi que vers la fin du paquet
\item la somme de contrôle du paquet
\item Sa priorité
\end{itemize}

\paragraph{}
Linux est capable de forwarder du flux, au niveau liaison (bridging) et au niveau réseau (routing).
Le flux est alors décapsulé respectivement jusqu'à la couche liaison et jusqu'à la couche réseau.
Cela permet de diriger se dernier vers la bonne interface, et si besoin de construire une en-tête
différente de la précédente (cas du bridging, avec changement de MAC source, du DNAT, du SNAT, et
du MASQUERADING), voire de changer de protocole de niveau liaison ou transport. Linux agit alors comme une
gateway.

\paragraph{}
Il est également possible de modifier le chemin prévu dans le datagramme (proxying, etc). On parle
alors dans ces cas là de "paquet mangling", puisque l'on va modifier des champs dans les en-têtes.
Sont également modifiés des champs comme le TTL, et un possible re-découpage des datagrammes peut
être fait, selon les spécification du réseau de sortie.

\paragraph{}
Ce traitement doit se faire de manière rapide afin de limiter la latence de transit, et doit pouvoir
être ordonnancé en fonction des besoins du réseau. Il s'agit d'une problématique complexe sur la
qualité de service induite par la latence. Une solution a été mise en place sous Linux, décrite
plus loin.

\paragraph{}
Netfilter est la pierre angulaire de tous ces traitements. Ce n'est pas lui qui implémente les
fonctions de la pile IP, mais il ordonnance leurs appels, en fonction des valeurs qu'elles retournent,
et selon les informations fournies par les {\it sk\_buffs}.

\paragraph{}
Netfilter s'appuie sur un schéma générique de traitement des paquets. Il définit 5 traitements
successifs au niveau IP :
\begin{itemize}
\item NF\_IP\_PREROUTING, qui va faire un traitement préalable au routage du paquet.
      C'est ici qu'iptables gère le DNAT par exemple. Ce traitement ce fait à l'arrivée des paquet en entrée
\item NF\_IP\_IN, pour le traitement avant la remontée vers la socket locale du paquet.
      Ce hook est utilisé pour la finalisation du traitement des paquets entrant.
\item NF\_IP\_FORWARD, pour le forwarding de paquet uniquement. C'est cette accroche qui va appeler
      le module de routage du noyau (traitement de la table de routage)
\item NF\_IP\_OUT, pour le pré-traitement des paquets en émission à partir d'une source locale
      uniquement.
\item NF\_IP\_POSTROUTING, pour le post-traitement du paquet en émission. Exécuté à la fois lors du routage
      et lors de l'émission de paquets depuis un service local. On y trouve par exemple les règles
      d'encapsulation IPSEC pour le mode tunnel. C'est le dernier à être appelé avant émission du paquet.
\end{itemize}
Ces cinq traitements sont également présents au niveau liaison, afin de répondre au besoin de
bridging. Cependant, NF\_BR\_PREROUTING et NF\_BR\_POSTROUTING sont constamment appelés. Le schéma
\ref{fig:nf_hooks} décrit le positionnement des différentes accroches Netfilter.

\begin{figure}
\input{pictures/nf_hooks.tex}
\label{fig:nf_hooks}
\caption{Positionnement des différentes accroches Netfilter sur la pile IP}
\end{figure}

\paragraph{}
Des exemples de services se basant sur les hooks de Netfilter sont les services de conntracking.
Un certain nombre de protocoles de niveau supérieur à la couche transport utilise plusieurs ports
pour fonctionner, en choisissant un port à la volée, durant une période d'initialisation. C'est
le cas du protocole FTP, sur le port 21, qui choisit dynamiquement un port pour émettre des données
binaires tout en maintenant le port 21 ouvert pour la signalisation.\\
Cependant, lorsqu'un firewall est actif sur la machine, on croit souvent être obligé de configurer
une plage de ports ouverts de manière statique afin de permettre ce cas d'emploi.
En réalité, il existe un module dans le noyau linux, qui s'accroche à Netfilter et qui va traiter
le protocole FTP dans le noyau, à la volée. Il décapsule le flux jusqu'à arriver au niveau du flux
FTP, afin de détecter la négociation de port. Une fois le port négocié, le module ouvre le port à
la volée entre le client et le serveur, ce qui permet au flux de données de traverse.

\paragraph{}
Il existe aujourd'hui un grand nombre de module de conntracking, allant du support du protocole FTP au
support des protocole SIP et H323.

\subsection{La pile USB}

\paragraph{}
L'architecture USB est un bloc volumineux de Linux. En effet, entre les différentes normes (OHCI et
UHCI pour l'USB 1.1, EHCI pour l'USB 2 et l'XHCI pour l'USB 3.0), les différents modes associés
(mode Interrupt, Bulk, etc) et les différents types de périphériques pouvant s'y connecter (disques
durs, caméra, contrôleurs réseau (ethernet ou Wifi), claviers, souris, etc.), le sous-système USB
est très consommateur à la fois de développeurs et de modules.

\paragraph{}
La pile USB Linux reprend, pour la dénomination de ses structures et ses champs, les noms définis
dans les normes associées, ce qui simplifie l'usage des API.\\
L'élément de base le plus fréquement utilisé dans le cadre des communications avec les
périphériques USB est l'{\it URB}. Il s'agit d'une structure de données faisant office de support
dans la communication entre pilote et périphérique. On peut le voir comme l'équivalent du {\it
sk\_buff} pour les interfaces réseaux.

\paragraph{}
Sous Linux, le système USB est vu comme un arbre. Les noeuds sont les hubs USB, gérés nativement
par le noyau via un thread spécifique nommé {\it khubd}. Ce démon est la porte de sortie des
différents évènements périphériques transitant par les hubs. C'est lui qui informe alors le noyau
qu'un évènement a eu lieu, et appelle le driver associé. {\it Khubd} est en attente d'évènement au
travers d'un mécanisme de polling, dont la période est une propriété fournie par le controlleur USB
matériel.

\FIXME: continuer, mettre un peu au propre ces qques paragraphes

\subsection{La sécurité et la cryptographie}
\paragraph{}

\subsection{Les pilotes de périphériques}
\paragraph{}

\section{Coder dans le noyau Linux}
\label{sec:linux_dev}

\subsection{Configurer et compiler un noyau Linux}
\paragraph{}

\subsection{Le système de production du noyau}
\paragraph{}

