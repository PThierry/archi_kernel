%%
%%
%% theo_kernel.tex for  in /doctorat/ece/partenariat/cours/archi_kernel
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Wed Sep 22 14:45:23 2010 Philippe THIERRY
%% Last update jeu. 30 sept. 2010 19:32:37 CEST Philippe THIERRY
%%

\chapter{Un petit historique du noyau}

\section{L'invention du noyau}

\section{Les noyaux monolithiques}

\paragraph{}
Historiquement le plus ancien, le noyau monolithique est la conséquence des ajouts incessants de
nouvelles fonctionnalités dans les noyaux au fur et à mesure de l'intégration de nouvelle
technologies.\\
En effet, les premiers noyaux ne possédaient pas de pile réseau et avait un nombre très faible de
drivers. Avec la création du réseau d'une part et l'hétérogénéisation du matériel d'autre part,
beaucoup de code fut ajouté aux noyaux.

\begin{figure}[ht]
\input{pictures/kernel_monolithic.tex}
\label{pic:kern_monolithic}
\caption{Répartition des services dans un noyau monolithique}
\end{figure}

\section{Les noyaux hybrides}

\paragraph{}
Exemple de GNU Hurd, noyau hybride écrit en C++, déportant une partie de ses modules dans un
domaine d'exécution dit de {\it service}, hors de l'espace d'adressage du noyau. Un plantage dans
cette zone de service ne provoque pas de plantage du noyau, du fait de cette séparation.

\begin{figure}[ht]
\input{pictures/kernel_hybrid.tex}
\label{pic:kern_hybrid}
\caption{Répartition des services dans un noyau hybride}
\end{figure}


\section{Les micro-noyaux}

\begin{figure}[ht]
\input{pictures/kernel_micro.tex}
\label{pic:kern_micro}
\caption{Les architectures à base de micro-noyaux}
\end{figure}


\section{Les noyaux d'aujourd'hui}

\subsection{Les exo-noyaux}

\paragraph{}
Il existe aujourd'hui des éléments d'architectures de type exo-noyaux. Il s'agit de noyau plus
petits encore que les micro-noyaux décrits au dessus. Le but est de fournir uniquement une couche
d'abstraction du matériel sans fournir d'éléments avancés tels qu'un ordonnanceur au niveau noyau.

\paragraph{}
Les exo-noyaux sont destinés à des architectures logicielles peu fréquentes (\FIXME continuer)

\subsection{Les hyperviseurs}

\paragraph{}
Bien que le principe de virtualisation date de 1973, son véritable essor date du début des années
2000, pour des raisons diverses :
\begin{itemize}
\item La puissance des machines, suffisante pour fournir plusieurs services simultanément 
\item La réduction du coût du matériel et de la consommation électrique
\item Un besoin de redondance logicielle, simple à gérer via la virtualisation
\item La possibilité de maquéter rapidement et efficacement des architectures réseaux complexes
\item Plus récemment un besoin de sécurité au travers du cloisonnement par la virtualisation. Ce
dernier élément est moins connu du grand public et s'appuie sur des solutions autres que les
célèbres VMWare et VirtualBox.
\end{itemize}

\paragraph{}
Parmis les différentes solutions de virtualisation, il existe les hyperviseurs, solutions basées
sur un noyau plus ou moins gros, dont l'accès n'est jamais direct. On passe alors par des consoles
de gestion (cas de certains hyperviseurs professionnels) ou des domaines virtuels dits "privilégiés"
(cas de Xen). Ces hyperviseurs fournissent des services de type paravirtualisation ou de type HVM
(Hardware-based Virtual-machine Monitor, s'appuyant sur des composants matériels tels que Intel VT
ou ARM TrustZone).

\begin{figure}[ht]
\input{pictures/kernel_hypervisor.tex}
\label{pic:kern_micro}
\caption{Les architectures logiciels des hyperviseurs}
\end{figure}

\paragraph{}
Les hyperviseurs permettent de supporter des machines virtuelles avec un choix plus ou moins riche
et un cloisonnement plus ou moins fort\footnote{Pour ceux que ça intéresse, il est intéressant
d'étudier le principe des système MILS
(\url{http://en.wikipedia.org/wiki/Multiple\_Independent\_Levels\_of\_Security}) en comparaison aux
solutions existantes de RTOS (Real-Time Operating Systems)}.

\chapter{Les noyaux UNIX}

\section{Introduction}
Afin de fournir aux applicatifs une interface normalisée leur permettant de s'abstraire des spécificités
du matériel mais également des différents noyaux existant, une norme fut créée au début des années 70 :
la norme POSIX.\\
Le but est que l'ensemble des noyaux existant soit compatible de cette norme, ceci afin de rendre
les applicatifs portable d'un noyau à un autre. Ce fut le cas de tous les noyaux monolithiques (hors
recherche)... jusqu'à l'arrivée de MS-DOS).

\paragraph{}
Arbre généalogique de la famille UNIX
\begin{figure}[ht]
\includegraphics[width=15cm]{pictures/unix_history}
\caption{Petit historique des UNIX libres (image Wikipedia)}
\label{fig:unix_genealogy}
\end{figure}

\section{Le langage C et la création d'UNIX}

\section{POSIX et la portabilité}

\section{La (grande) famille BSD}


\chapter{Un petit passage par Windows}

\section{Microsoft DOS}

\paragraph{}
Anecdote sur IBM cherchant un fournisseur d'OS pour son nouveau produit : le PC

\paragraph{}
Le premier noyau de Microsoft, basé sur DOS

\section{Les noyaux NT}

\section{Vista et 7}

\paragraph{}
Une architecture de type micro-noyau
