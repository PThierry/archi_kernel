%%
%%
%% theo_kernel.tex for  in /doctorat/ece/partenariat/cours/archi_kernel
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Wed Sep 22 14:45:23 2010 Philippe THIERRY
%% Last update lun. 30 mai 2011 12:44:53 CEST Philippe THIERRY
%%

\chapter{Un petit historique du noyau}

\section{L'invention du noyau}

L'invention du noyau vient du fait qu'il devenait nécessaire d'implémenter un couche logicielle
permettant d'abstraire le matériel sous-jacent. Cela permettait de réduire l'effort de
développement logiciel.\\
Très vite, le besoin de faire s'exécuter plusieurs taches est arrivé, avec l'accroissement de la
puissance des machine. Les premiers ordonnanceurs faisait des traitement non préemptif, de type
FIFO. Cela permettait de charger un certain nombre de travaux le soir pour en récupérer les
résultats le lendemain.\\
Ces besoins étaient liés au fait que la ressource informatique, du fait de sa rareté, était
précieuse : il était nécessaire de louer la puissance de calcul afin de lancer ses
taches. Une fois le bail arrivé à son terme, il était parfois nécessaire d'attendre plusieurs jours
pour avoir de nouveau accès à la machine.\\
Avec l'accroissement des capacités des ordinateurs sont nés des noyaux plus intelligent, capable de
fournir des services plus riches aux applicatifs. Ce fut le cas de la création des systèmes de
fichiers ou des interface d'accès à des périphériques comme les imprimantes. Au fur et à mesure, de
nouveaux services furent intégrés aux noyaux, comme le support du clavier et de l'écran, arrivés
plus tard, ou encore des premiers réseaux dans les années 60.\\
\`{A} la fin des années soixante, une première norme fut créée pour définir une interface unique
pour les applicatifs, afin de réduire le problème de portabilité à une époque ou aucune norme
d'interface utilisateur n'existait. Ce fut la norme UNIX 1003.1, qui définit une première version
d'interface standardisée. Avec cette norme sont nés les premiers noyaux écrit dans un langage
évolué (n'étant pas de l'assembleur) : le C. Il s'agit de la famille UNIX, dont les premiers
membres furent Unics (en 1969) et Unix TSS, à partir desquels naquirent BSD, HP-UX ou encore
SUN-OS, à partir de la fin des années 70. Tous ces noyaux étaient de type monolithiques : ils
intégraient l'ensemble des services nécessaires pour gérer l'intégralité du matériel et des
services requis pour permettre aux taches de fonctionner correctement.

\section{Les noyaux monolithiques}

\paragraph{}
Historiquement le plus ancien, le noyau monolithique est la conséquence des ajouts incessants de
nouvelles fonctionnalités dans les noyaux au fur et à mesure de l'intégration de nouvelle
technologies.\\
En effet, les premiers noyaux ne possédaient pas de pile réseau et avait un nombre très faible de
drivers. Avec la création du réseau d'une part et l'hétérogénéisation du matériel d'autre part,
beaucoup de code fut ajouté aux noyaux.

\begin{figure}[ht]
\input{pictures/kernel_monolithic.tex}
\label{pic:kern_monolithic}
\caption{Répartition des services dans un noyau monolithique}
\end{figure}

\section{Les noyaux hybrides}

\paragraph{}
Exemple de GNU Hurd, noyau hybride écrit en C++, déportant une partie de ses modules dans un
domaine d'exécution dit de {\it service}, hors de l'espace d'adressage du noyau. Un plantage dans
cette zone de service ne provoque pas de plantage du noyau, du fait de cette séparation.

\begin{figure}[h!]
\input{pictures/kernel_hybrid.tex}
\label{pic:kern_hybrid}
\caption{Répartition des services dans un noyau hybride}
\end{figure}


\section{Les micro-noyaux}

\paragraph{}
Les micro-noyaux ont pour but de réduire le plus possible le code s'exécutant avec les droits
d'administrateurs sur la machine. Ils ont de bonnes propriétés de sécurité, principalement du fait
de leur faible complexité. De plus, il génèrent un faible overhead car ne fournissant pas de
service à forte valeur ajoutée (comme une pile réseau) pouvant impacter la durée d'exécution des
taches qu'ils ordonnancent.

\paragraph{}
Il faut cependant bien prendre en compte que l'ensemble des éléments à valeurs ajoutée (les
services dans les noyau hybrides) doivent être implémenter comme des éléments applicatifs
(bibliothèques et taches). On a par contre une meilleure maîtrise de leur ordonnancement.

\paragraph{}
La plupart des noyaux professionnels pour les besoins Temps Réel et de Sécurité sont des
micro-noyaux : Vxworks, velOSity, Integrity ou encore PikeOS.

\begin{figure}[ht]
\input{pictures/kernel_micro.tex}
\label{pic:kern_micro}
\caption{Les architectures à base de micro-noyaux}
\end{figure}


\section{Les noyaux d'aujourd'hui}

\subsection{Les exo-noyaux}

\paragraph{}
Il existe aujourd'hui des éléments d'architectures de type exo-noyaux. Il s'agit de noyau plus
petits encore que les micro-noyaux décrits au dessus. Le but est de fournir uniquement une couche
d'abstraction du matériel sans fournir d'éléments avancés tels qu'un ordonnanceur au niveau noyau.

\subsection{Les hyperviseurs}

\paragraph{}
Bien que le principe de virtualisation date de 1973, son véritable essor date du début des années
2000, pour des raisons diverses :
\begin{itemize}
\item La puissance des machines, suffisante pour fournir plusieurs services simultanément 
\item La réduction du coût du matériel et de la consommation électrique
\item Un besoin de redondance logicielle, simple à gérer via la virtualisation
\item La possibilité de maquéter rapidement et efficacement des architectures réseaux complexes
\item Plus récemment un besoin de sécurité au travers du cloisonnement par la virtualisation. Ce
dernier élément est moins connu du grand public et s'appuie sur des solutions autres que les
célèbres VMWare et VirtualBox.
\end{itemize}

\paragraph{}
Parmis les différentes solutions de virtualisation, il existe les hyperviseurs, solutions basées
sur un noyau plus ou moins gros, dont l'accès n'est jamais direct. On passe alors par des consoles
de gestion (cas de certains hyperviseurs professionnels) ou des domaines virtuels dits "privilégiés"
(cas de Xen). Ces hyperviseurs fournissent des services de type paravirtualisation ou de type HVM
(Hardware-based Virtual-machine Monitor, s'appuyant sur des composants matériels tels que Intel VT
ou ARM TrustZone).

\begin{figure}[ht]
\input{pictures/kernel_hypervisor.tex}
\label{pic:kern_micro}
\caption{Les architectures logicielles des hyperviseurs}
\end{figure}

\paragraph{}
Les hyperviseurs permettent de supporter des machines virtuelles avec un choix plus ou moins riche
et un cloisonnement plus ou moins fort\footnote{Pour ceux que ça intéresse, il est intéressant
d'étudier le principe des système MILS
(\url{http://en.wikipedia.org/wiki/Multiple\_Independent\_Levels\_of\_Security}) en comparaison aux
solutions existantes de RTOS (Real-Time Operating Systems)}.

\chapter{Petit état de l'art des noyaux d'ajourd'hui}

\section{Les noyaux UNIX et dérivés}

\paragraph{}
Cette famille de noyau correspond principalement à des noyaux écrit en C (à l'exception notable de
Hurd) et respectant plus ou moins complètement la norme POSIX.\\
Le langage C a été écrit par deux informaticiens américain : Brian Kernighan et Dennis Ritchie. Ils
sont également co-auteurs (avec d'autres) du premier UNIX, qui fut écrit principalement en C.
Afin de fournir aux applicatifs une interface normalisée leur permettant de s'abstraire des spécificités
du matériel mais également des différents noyaux existant, une norme fut créée au début des années 70 :
la norme POSIX.\\
Le but est que l'ensemble des noyaux existant soit compatible de cette norme, ceci afin de rendre
les applicatifs portable d'un noyau à un autre. Ce fut le cas de la plupart des noyaux monolithiques - hors
recherche - jusqu'à l'arrivée de MS-DOS.

\paragraph{}
Arbre généalogique de la famille UNIX
\begin{figure}[ht]
\includegraphics[width=15cm]{pictures/unix_history}
\caption{Petit historique des UNIX libres (image Wikipedia)}
\label{fig:unix_genealogy}
\end{figure}


\section{La (grande) famille BSD}


\chapter{Un petit passage par Windows}

\section{Microsoft DOS}

\paragraph{}
Anecdote sur IBM cherchant un fournisseur d'OS pour son nouveau produit : le PC

\paragraph{}
Le premier noyau de Microsoft, basé sur DOS

\section{Les noyaux NT}

\section{Vista et 7}

\paragraph{}
Une architecture de type micro-noyau
